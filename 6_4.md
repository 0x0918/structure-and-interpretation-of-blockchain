# Bucket Tree

可以看到MPT树的设计已经解决了之前提出的问题，那为什么又会出现`Bucket Tree`呢?软件工程中没有银弹可以一劳永逸的解决所有问题，在联盟链场景中MPT树就暴露了很多问题。

在智能合约状态存储方面，MPT树解决了海量合约和琐碎状态存储查询的问题，由于其复杂性，尽管有采用了大量的优化手段，但是在一些场景性能仍然不佳，比如在联盟链中，不需要大量的合约，合约状态的变更集中在少数几个合约中，其变更非常的快速。

整条链只是为少量的合约服务，这个时候MPT树就会成为性能瓶颈。

&emsp;&emsp;Bucket Tree拓展了哈希表的概念，引入了一个桶（bucket），也就是哈希桶。

&emsp;&emsp;其结构如下图所示:

![](https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_6/6_10.jpg?raw=true)

&emsp;&emsp;KEY2和KEY3映射到相同的152号桶里。

&emsp;&emsp;Bucket tree在扩展哈希表的同时，又在哈希表上建立了默克尔树。

![](https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_6/6_11.jpg?raw=true)

&emsp;&emsp;哈希表由一系列的哈希桶（bucket）组成，每个桶中存储着若干被散列到该桶中的数据项（entry）所以数据项按序排列，每一个哈希桶有一个哈希值来标识整个桶，该哈希值是桶内所有数据通过哈希计算所得。

&emsp;&emsp;除了底层的哈希表外，上层是一系列的默克尔树节点，一个默克尔树节点对应着下层的N个哈希桶或者默克尔树节点，这个N也称作默克尔树的聚合度。

## 如此设计的目的：

* 利用默克尔树的特点，使每次树状态改变，重新计算哈希的代价最小；
* 利用哈希表进行底层数据的维护，使得数据项均匀分布；

&emsp;&emsp;例如上图中，一条新的数据项entry5插入，该数据项被散列到POS为1的桶中。该桶，即从该桶至根节点上所有的节点被标为粉红色，即为脏节点。仅对这些脏节点进行哈希重计算，便可得到一个新的哈希值用来代表新的树状态。

&emsp;&emsp;由于bucket tree是一棵固定大小的树（即底层的哈希表容量在树初始化之后，就无法更改了），随着数据量的增大，采用散列函数将所有的数据项进行均匀散列可以避免数据聚集的情况发生。

## 重要参数

Bucket tree有两个重要的可调参数；

- capacity：表示哈希表的容量，该值越大，整课树所能容纳的数据项个数就越多，在聚合程度不变的前提下，树越高，从叶子节点到根节点的路径越长，哈希计算次数也越多。
- aggreation：表示一个父节点对应的孩子节点的个数，该值越大，表示树的收敛速度越快，在哈希表容量不变的前提下，树更低，从叶子节点到根节点路径越短，哈希计算次数也越少。但是每个默克尔树节点的size就越大，增加磁盘IO开销。

## Tips:
- 当有比较多数据变更的时候，非常容易散列到不同bucket，这个时候可以并行计算新bucket的哈希值，加速构建默克尔树。
- 如果Bucket tree树比较大，并且用数据库来存储的话，加上读cache可以显著的提升性能。
