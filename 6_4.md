# 字典树
区块头中有一个`Merkle Root`的字段保存了交易列表的默克尔树根的哈希，为了计算这个值需要消耗大量的计算资源，回想一下默克尔树的根哈希计算方法，当一个区块的交易达到两三千笔的时候，两两计算哈希直到默克尔树根哈希的计算量是多么的庞大。如果刚计算完成得到根哈希，这时区块中的一笔交易由于一些原因发生了变化又需要从头开始计算。比如收到了一个新区块，新区块的交易和自己打包的交易有少量重叠，这时需要替换这些重叠交易重新计算根哈希。

默克尔树还有一个缺点，叶子节点的内容没有发生改变，但是次序发生变化得到的根哈希又不一致。

如果我们用哈希表，链表，数组之类的数据结构存储默克尔树的叶子节点就不可避免的出现上面的问题，为此就需要设计一种数据结构，在存储叶子节点的同时，即可当叶子节点发生变化的时候减少哈希计算量，还可避免内容次序不一致导致的根哈希不一致的问题。

为此引入了一种新的数据结构`字典树`。
## 字典树（Trie）

Trie又称前缀树或字典树，是一种有序树，用于保存关联数据，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。

下图是一颗典型的前缀树；

![](https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_6/6_3.png?raw=true)

图中前缀树存储了一些字符串，蓝色的是关键字，存储的字符串由关键字组成。存储了"a", "to", "tea", "ted", "ten", "i", "in", "inn"。
前缀树有这些特点；
- 根节点不包含字符，其他节点各包含一个字符；
- 关键路径节点的字符连接起来为该节点所存储的数据；

> 关键路径就是每个节点有一个标志位，用来标记这个节点是否作为构成数据的一部分，上图中的，t, e 节点就不是关键路径。

Trie的核心思想就是用空间换时间，利用公共前缀缩小要比较的范围来达到快速查找的目的。

如果Trie树叶上的数据发生了变化，只需要计算树叶到根路径上的哈希即可，避免了全量的哈希计算，相较于哈希表的方式，牺牲了一定的查询速度，多浪费了一些空间，但是也避免了大量的计算。

虽然相较于哈希表，插入和查询速度有不足，但是trie的插入和查询的效率依然算是非常高效的，都是O(m)，m是插入或查询字符串的长度，同时trie也支持了对数据按照字典序排序，这也是哈希表所不具备的特点。

对数据支持字典排序是一个非常重要的特性，相同的数据不同的顺序可能生成不同的根哈希，会误认为数据发生了变化，实际上数据本身没有改变，只是顺序发生了改变而已。

除此之外trie还在这些场景有广泛的应用；
- 但词频次统计。
- 字符串匹配。
- 字符串字典序排序。
- 前缀匹配，比如一些搜索框的自动提示。

## 压缩字典树
在字典树中很多节点只是为了存储前缀而存在，当路径上只有一个关键字的时候，这些只为存储前缀存在的节点就显得非常冗余。压缩字典树在字典树的基础之上做了一些优化，具体可以看下图；

![](https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_6/6_4.jpg?raw=true)

图中黑色的是关键路径，存储了字符串"abc"和"d"，可以明显看到压缩后的前缀树占用了更小的空间。
