# Solidity汇编
Solidity 定义了一种汇编语言，在没有 Solidity 的情况下也可以使用。这种汇编语言也可以嵌入到 Solidity 源代码中当作“内联汇编”使用。我们从如何使用内联汇编开始，介绍它如何区别于独立汇编语言，然后详细讲述这种汇编语言。

# 内联汇编
为了实现更细粒度的控制，尤其是为了通过编写库来增强语言，可以利用接近虚拟机的语言将内联汇编与 Solidity 语句结合在一起使用。

从一个例子直观的感受一下内联汇编。
```solidity
pragma solidity ^0.5.0;

contract Assembly {
    function example(uint num) public pure returns(uint256){
        assembly{
            num:=add(num,1)
        }
        return num;
    }
}
```
这个例子用内联汇编实现了将传入的数加一的操作。

## 基本语法
内联汇编程序由`assembly{...}`来标记，表示大括号里面是内联汇编的代码。

## 操作码

## 字面常量
你可以直接键入十进制或十六进制符号来作为整型常量使用，这会自动生成相应的 PUSHi 指令。 下面的代码将计算 2 加 3（等于 5），然后计算其与字符串 “abc” 的按位与。字符串在存储时为左对齐，且长度不能超过 32 字节。

`assembly { 2 3 add "abc" and }`

## 函数风格
你可以像使用字节码那样在操作码之后键入操作码。例如，把 3 与内存位置 0x80 处的数据相加就是`3 0x80 mload add 0x80 mstore`由于通常很难看到某些操作码的实际参数是什么，所以 Solidity 内联汇编还提供了一种“函数风格”表示法，同样功能的代码可以写做`mstore(0x80, add(mload(0x80), 3))`函数风格表达式内不能使用指令风格的写法，即 1 2 mstore(0x80, add) 是无效汇编语句， 它必须写成 mstore(0x80, add(2, 1)) 这种形式。对于不带参数的操作码，括号可以省略。

注意，在函数风格写法中参数的顺序与指令风格相反。如果使用函数风格写法，第一个参数将会位于栈顶。

## 访问外部变量和函数
通过简单使用它们名称就可以访问 Solidity 变量和其他标识符。对于内存变量，这会将地址而不是值压入栈中。 存储变量是不同的，因为存储变量的值可能不占用完整的存储槽，因此其“地址”由存储槽和槽内的字节偏移量组成。 为了获取变量 x 所使用的存储槽，你可以使用 x_slot，并用的 x_offset 获取其字节偏移量。

在赋值语句中（见下文），我们甚至可以使用 Solidity 局部变量来赋值。

对于内联汇编而言的外部函数也可以被访问：汇编会将它们的入口标签（带有虚拟函数解析）压入栈中。Solidity 中的调用语义为：

调用者压入 return label、arg1、arg2、…、argn

被调用方返回 ret1、ret2、…、retm

这个特性使用起来还是有点麻烦，因为在调用过程中堆栈偏移量发生了根本变化，因此对局部变量的引用将会出错。
```
pragma solidity ^0.5.0;

contract C {
    uint b = 10;
    function f(uint x) public view returns (uint r) {
        assembly {
            r := mul(x, sload(b_slot)) // 因为偏移量为 0，所以可以忽略
        }
    }
}
```

如果你访问一个实际数据位数小于 256 位的数据类型（比如 uint64、address、bytes16 或 byte）， 不要对这种类型经过编码后未使用的数据位上的数值做任何假设。尤其是不要假设它们肯定为 0。 安全起见，在某个上下文中使用这种数据之前，请一定先将其数据清空为 0，这非常重要： uint32 x = f(); assembly { x := and(x, 0xffffffff) /* now use x */ } 要清空有符号类型，你可以使用 signextend 操作码。


## 汇编局部变量声明

你可以使用 let 关键字来声明只在内联汇编中可见的变量，实际上只在当前的 {...} 块中可见。 下面发生的事情应该是：let 指令将创建一个为变量保留的新数据槽，并在到达块末尾时自动删除。 你需要为变量提供一个初始值，它可以只是 0，但它也可以是一个复杂的函数风格表达式。
```
pragma solidity ^0.5.0;

contract C {
    function f(uint x) public view returns (uint b) {
        assembly {
            let v := add(x, 1)
            mstore(0x80, v)
            {
                let y := add(sload(v), 1)
                b := y
            } // y 会在这里被“清除”
            b := add(b, v)
        } // v 会在这里被“清除”
    }
}
```

## 赋值
可以给汇编局部变量和函数局部变量赋值。请注意：当给指向内存或存储的变量赋值时，你只是更改指针而不是数据。

有两种赋值方式：函数风格和指令风格。对于函数风格赋值（变量 := 值），你需要在函数风格表达式中提供一个值，它恰好可以产生一个栈里的值； 对于指令风格赋值（=: 变量），则仅从栈顶部获取数据，指令风格的赋值方式官方已经不推荐使用。对于这两种方式，冒号均指向变量名称。赋值则是通过用新值替换栈中的变量值来实现的。
```
{
    let v := 0 // 作为变量声明的函数风格赋值
    let g := add(v, 2)
    sload(10)
    =: v // 指令风格的赋值，将 sload(10) 的结果赋给 v
}
```

## 条件判断与循环语句

### If关键字
if 语句可以用于有条件地执行代码，且没有“else”部分；如果需要多种选择，你可以考虑使用“switch”（见下文）。
```
{
    if eq(value, 0) { revert(0, 0) }
}
```
代码主体的花括号是必需的。

### Switch关键字
作为“if/else”的非常初级的版本，你可以使用 switch 语句。它计算表达式的值并与几个常量进行比较。选出与匹配常数对应的分支。 与某些编程语言容易出错的情况不同，控制流不会从一种情形继续执行到下一种情形。我们可以设定一个 fallback 或称为 default 的默认情况。
```solidity
{
    let x := 0
    switch calldataload(4)
    case 0 {
        x := calldataload(0x24)
    }
    default {
        x := calldataload(0x44)
    }
    sstore(0, div(x, 2))
}
```
Case 列表里面不需要大括号，但 case 主体需要。

### For关键字循环
汇编语言支持一个简单的 for-style 循环。For-style 循环有一个头，它包含初始化部分、条件和迭代后处理部分。 条件必须是函数风格表达式，而另外两个部分都是语句块。如果起始部分声明了某个变量，这些变量的作用域将扩展到循环体中（包括条件和迭代后处理部分）。

下面例子是计算某个内存区域中的数值总和。
```
{
    let x := 0
    for { let i := 0 } lt(i, 0x100) { i := add(i, 0x20) } {
        x := add(x, mload(i))
    }
}
```
For 循环也可以写成像 while 循环一样：只需将初始化部分和迭代后处理两部分留空。
```
{
    let x := 0
    let i := 0
    for { } lt(i, 0x100) { } {     // while(i < 0x100)
        x := add(x, mload(i))
        i := add(i, 0x20)
    }
}
```

## 函数

汇编语言允许定义底层函数。底层函数需要从栈中取得它们的参数（和返回 PC），并将结果放入栈中。调用函数的方式与执行函数风格操作码相同。

函数可以在任何地方定义，并且在声明它们的语句块中可见。函数内部不能访问在函数之外定义的局部变量。这里没有严格的 return 语句。

如果调用会返回多个值的函数，则必须使用 a，b：= f(x) 或 let a，b：= f(x) 的方式把它们赋值到一个元组。

下面例子通过平方和乘法实现了幂运算函数。
```
{
    function power(base, exponent) -> result {
        switch exponent
        case 0 { result := 1 }
        case 1 { result := base }
        default {
            result := power(mul(base, base), div(exponent, 2))
            switch mod(exponent, 2)
                case 1 { result := mul(base, result) }
        }
    }
}
```

## 注意事项
内联汇编语言看起来像高级语言，但实际上它是非常低级的编程语言。函数调用、循环、if 语句和 switch 语句通过简单的重写规则进行转换， 然后，汇编程序为你做的唯一事情就是重新组织函数风格操作码、管理 jump 标签、计算访问变量的栈高度，还有在到达语句块末尾时删除局部汇编变量的栈数据。 特别是对于最后两种情况，汇编程序仅会按照代码的顺序计算栈的高度，而不一定遵循控制流程；了解这一点非常重要。此外，swap 等操作只会交换栈内的数据，而不是变量位置。

## Solidity 惯例
与 EVM 汇编语言相比，Solidity 能够识别小于 256 位的类型，例如 uint24。为了提高效率，大多数算术运算只将它们视为 256 位数字， 仅在必要时才清除未使用的数据位，即在将它们写入内存或执行比较之前才会这么做。这意味着，如果从内联汇编中访问这样的变量，你必须先手工清除那些未使用的数据位。

Solidity 以一种非常简单的方式管理内存：在 0x40 的位置有一个“空闲内存指针”。如果你打算分配内存，只需从此处开始使用内存，然后相应地更新指针即可。

内存的开头 64 字节可以用来作为临时分配的“暂存空间”。“空闲内存指针”之后的 32 字节位置（即从 0x60 开始的位置）将永远为 0，可以用来初始化空的动态内存数组。

在 Solidity 中，内存数组的元素总是占用 32 个字节的倍数（是的，甚至对于 byte[] 都是这样，只有 bytes 和 string 不是这样）。 多维内存数组就是指向内存数组的指针。动态数组的长度存储在数组的第一个槽中，其后才是数组元素。

# 独立汇编

内联汇编描述的汇编语言也可以单独使用，实际上，计划是将其用作Solidity编译器的中间语言。在这种意义下，它试图实现以下几个目标：

1、即使代码是由 Solidity 的编译器生成的，用它编写的程序应该也是可读的。 2、从汇编到字节码的翻译应该尽可能少地包含“意外”。 3、控制流应该易于检测，以帮助进行形式化验证和优化。

为了实现第一个和最后一个目标，汇编提供了高级结构：如 for 循环、if 语句、switch 语句和函数调用。 应该可以编写不使用明确的 SWAP、DUP、JUMP 和 JUMPI 语句的汇编程序，因为前两个混淆了数据流，而最后两个混淆了控制流。 此外，形式为 mul(add(x, y), 7) 的函数风格语句优于如 7 y x add mul 的指令风格语句，因为在第一种形式中更容易查看哪个操作数用于哪个操作码。

第二个目标是通过采用一种非常规则的方式来将高级高级指令结构便以为字节码。 汇编程序执行的唯一非局部操作是用户自定义标识符（函数、变量、…）的名称查找，它遵循非常简单和固定的作用域规则并从栈中清除局部变量。