# EVM简介
`EVM`全称是以太坊虚拟机（Ethereum Virtual Machine），它为以太坊提供了区块链系统的运行时环境。这个运行时环境是一个沙盒环境，在运行期间不能访问宿主机的网络，文件，系统，即使不同的合约之间也只有限的访问权限。智能合约中的代码必须经历从人类编写的高级语言代码到机器可读代码的转换。这需要将文本转换为十六进制值，从而将代码转换为字节码。字节码由编译器生成在区块链上经由EVM处理后执行。

结合以太坊的特点，以太坊开发组为EVM给出了下面这些主要设计目标：
- 简单性，操作码尽可能少且低级，数据类型尽可能少，虚拟机的结构尽可能简单。
- 确定性，EVM的语句没有产生歧义的空间，结果在不同机器上的执行结果是确定一致的。
- 节约空间，EVM的组件尽可能紧凑。
- 区块链定制化的，必须可以处理20bytes的账户地址，自定义32bytes密码学算法的等。
- 安全模型简单安全，Gas的计价模型应该是简单易行准确的。
- 便于优化，以便即时编译（JIT）和VM的性能优化。

为了满足这些目标，EVM被设计成了基于栈的虚拟机。它提供了一个抽象层，允许代码跨平台运行和移植，市面上支持Solidity合约的绝大部分链都是对EVM进行了移植。就像其他基于堆栈的编程语言一样，你输入的最后一个输入是你取出的第一个输入。这是后进先出（LIFO）的概念。它使用零地址格式指令集，其中操作数始终位于已知位置。这不需要寄存器中的地址，因为堆栈中的值是临时的。因此，当执行操作时，将“弹出”堆栈顶部的值，并将结果值“推”回堆栈中，这个也叫逆波兰表示。

让我们来看下面的例子。
```
x = 12 + 4 * 5 
```
对于这个简单的式子，x等于4和5乘以12的乘积。

基于栈使用后进先出的原则后，对它的读取就大不相同了。在这种情况下，公式将类似于此示例。
```
x = 4 5 * 12 +
```
从调用堆栈中读取的方式为：取值4和5，然后相乘，将值弹出堆栈，然后将结果乘积放在堆栈顶部。然后取乘积和值12以获得x的总和，然后将值弹出堆栈。将总和x推回堆栈顶部。

<img src="https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_5/5_1.png?raw=true" width="60%" height="60%">

在这两种情况下，我们为此操作获得的结果均为32。将数据放入调用堆栈的操作使用的是PUSH方法，而删除数据的操作称为POP方法。

将代码从人类可读的ASCII字符编译为机器可读的十六进制字符只是第一步。接下来，机器码必须执行所谓的操作码。操作码或操作代码告诉计算机要执行哪些操作。我们有操作数，操作的数据取决于操作符将执行的操作。

这是一个执行托管功能的简单智能合约。
```solidity
pragma solidity ^0.5.1;
contract Escrow {
    address agent;
    mapping(address => uint256) public deposits;
    modifier onlyAgent() { 
        require(msg.sender == agent);
        _;
    }
    
    constructor () public {
        agent = msg.sender;
    }
    
    function deposit(address payee) public onlyAgent payable {
        uint256 amount = msg.value;
        deposits[payee] = deposits[payee] + amount;
    }
    
    function withdraw(address payable payee) public onlyAgent {
        uint256 payment = deposits[payee];
        deposits[payee] = 0;
        payee.transfer(payment);
    }
}
```

以下是从编译后的代码生成的字节码，其中省略了很多无用的细节。

```
{
	"linkReferences": {},
	"object": "608060405234801  ......  f6c634300050b0032",
	"opcodes": "PUSH1 0x80 PUSH1 0x40 ...... STATICCALL 0xcd 0x2e 0xd4 PUSH31 0x9DAFE57C1B293C8318B01C0A92B343C29F3364736F6C634300050B00320000 ",
	"sourceMap": "25:594:0:-;;;218:57;8:9:- ...... 25:594;;;;;;"
}
```

操作码（opcodes）是由CPU执行的汇编语言命令。实际上，开发者可以使用汇编而不是高级编程代码来实现相同的目的，但是要复杂得多。对于绝大多数的应用场景来说，是没有使用汇编编写合约必要的。

智能合约将被部署在区块链上，应用程序二进制接口（Application binary interface）简称ABI，提供一种标准方法来通过网络与智能交互的合同。它允许外部应用程序和合同到合同的交互。开发人员在其应用程序或分布式应用程序（DApp）中使用ABI 来访问智能合约中的方法和功能。

下面就是托管合约Escrow的ABI。
```json
[ 
    { 
        "constant": false,
        "inputs": [ 
            { 
                "name": "payee",
                "type": "address" 
            } 
        ],
        "name": "withdraw",
        "outputs": [],
        "payable" : false,
        "stateMutability": "nonpayable",
        "type": "function" 
    },
    { 
        "constant": false,
        "inputs": [ 
            { 
                "name": "payee",
                "type": "address"
            } 
        ],
        "ame": "deposit",
        "utputs": [],
        "payable": true,
        "stateMutability": "payable",
        "type": "function" 
    },
    { 
        "constant": true,
        "inputs": [
            { 
                "name": "",
                "type": "address" 
            } 
        ],
        "name": "deposits",
        "outputs": [ 
            { 
                "name": "",
                "type": "uint256"
            } 
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    { 
        "inputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "constructor"
    } 
]
```

将智能合约部署到区块链后，EVM将在字节码中执行编译后的代码的操作码。如果函数需要改变区块链的状态，则会向合约的所有者收取一个称为gas（以wei 为单位）的计算单位。这些成本遵循以太坊协议，该协议要求在整个网络上花费计算成本，这是支付给矿工的费用，这些矿工将验证放入区块中的交易。简单的调用函数不需要更改区块链的状态，不会消耗汽油，因此是免费的。一个例子是对智能合约中的储值进行余额查询。

当智能合约由EVM部署并执行时，它现在位于区块链上。它将变得不可变，同时又透明，这意味着它不能直接更改，并且可以被公众看到。

下图展示了智能合约，操作码和二进制之间的关系。
<img src="https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_5/5_2.png?raw=true" width="60%" height="60%">


如果把EVM单独拿出来来看，就可以看到EVM的基本体系结构，如下图所示。
<img src="https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_5/5_3.png?raw=true" width="60%" height="60%">

其中EVM code就是编写的智能合约代码，PC是程序计数器，指向当前执行的指令，Stack和Memory暂存了合约在运行过程中的数据，storage存储了合约需要持久化的数据，对于EVM来说合约数据是不可变的，storage的数据是需要永久保存在链上的，其他数据都是合约中允许中产生的临时数据。


下图显示了EVM的不同部分如何相互交互以使以太坊发挥其神奇作用
<img src="https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_5/5_4.png?raw=true" width="60%" height="60%">

## EVM基本信息
基于栈的虚拟机实现简单，移植性也非常好，这也是以太坊选择基于栈的虚拟机的重要原因，前文的逆波兰表达法已经展示了如何采用栈来完成基本的运算，但是在EVM中的实现要复杂一些，下图展示了EVM中的栈是如何实现的。

![](https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_5/5_1.jpg?raw=true)

EVM采用了32字节（256bit）的`字长`，最多可以容纳2014个`字`，`字`为最小的操作单位。

Solidity是针对EVM设计的高级语言，提供了很多安全检查和限制，同时为了更加充分的利用EVM，Solidity也提供了更加底层贴近EVM的汇编语言，我们将通过具体的汇编代码一步一步的深入EVM。

## Solidity汇编
Solidity 定义了一种汇编语言，在没有 Solidity 的情况下也可以使用。这种汇编语言也可以嵌入到 Solidity 源代码中当作“内联汇编”使用。我们从如何使用内联汇编开始，介绍它如何区别于独立汇编语言，然后讲述这种汇编语言。

## 内联汇编
为了实现更细粒度的控制，尤其是为了通过编写库来增强语言，可以利用接近虚拟机的语言将内联汇编与 Solidity 语句结合在一起使用。

从一个例子直观的感受一下内联汇编。
```solidity
pragma solidity ^0.5.0;

contract Assembly {
    function example(uint num) public pure returns(uint256){
        assembly{
            num:=add(num,1)
        }
        return num;
    }
}
```
这个例子用内联汇编实现了将传入的数加一的操作。

### 基本语法
内联汇编程序由`assembly{...}`来标记，表示大括号里面是内联汇编的代码。

### 操作码
操作码就是EVM指令序列，用来告诉EVM需要执行哪一条指令的意思。通俗的讲就是计算机程序中所规定的要执行操作的那一部分指令。

指令系统的每一条指令都有一个操作码，表示该指令应进行什么性质的操作。不同的指令用操作码这个字段的不同编码来表示，每一种编码代表一种指令。EVM的指令序列一直在不断的优化，有些指令会被逐渐废弃，也会引入一些新的指令。下面列出了一些比较稳定的指令，方便后面对Solidity编译后的汇编代码进行分析。

|  指令   | 解释  |
|  ----  | ----  |
| stop  | 停止执行，与 return(0,0) 等价 |
| add(x, y)  | x + y |
| sub(x, y)  | x - y |
| mul(x, y)  | x * y |
| div(x, y)  | x / y |
| sdiv(x, y)  | x / y，以二进制补码作为符号 |
| mod(x, y)  | x % y |
| smod(x, y)  | x % y，以二进制补码作为符号 |
| exp(x, y)  | x 的 y 次幂 |
| not(x)  | ~x，对 x 按位取反 |
| lt(x, y)  | 如果 x < y 为 1，否则为 0 |
| gt(x, y)  | 如果 x > y 为 1，否则为 0 |
| slt(x, y)  | 如果 x < y 为 1，否则为 0，以二进制补码作为符号 |
| sgt(x, y)  | 如果 x > y 为 1，否则为 0，以二进制补码作为符号 |
| eq(x, y)  | 如果 x == y 为 1，否则为 0 |
| iszero(x)  | 如果 x == 0 为 1，否则为 0 |
| and(x, y)  | x 和 y 的按位与 |
| or(x, y)  | x 和 y 的按位或 |
| xor(x, y)  | x 和 y 的按位异或 |
| byte(n, x)  | x 的第 n 个字节，这个索引是从 0 开始的 |
| addmod(x, y, m)  | 任意精度的 (x + y) % m |
| mulmod(x, y, m)  | 任意精度的 (x * y) % m |
| signextend(i, x)  | 对 x 的最低位到第 (i * 8 + 7) 进行符号扩展 |
| keccak256(p, n)  | keccak(mem[p…(p + n))) |
| jump(label)  | 跳转到标签 / 代码位置 |
| jumpi(label, cond)  | 如果条件为非零，跳转到标签 |
| pc  | 当前代码位置 |
| pop(x)  | 弹出栈顶的 x 个元素 |
| dup1 … dup16  | 将栈内第 i 个元素（从栈顶算起）复制到栈顶 |
| swap1 … swap16  | 将栈顶元素和其下第 i 个元素互换 |
| mload(p)  | mem[p…(p + 32)) |
| mstore(p, v)  | mem[p…(p + 32)) := v |
| mstore8(p, v)  | mem[p] := v & 0xff （仅修改一个字节） |
| sload(p)  | storage[p] |
| sstore(p, v)  | mstorage[p] := v |
| msize  | 内存大小，即最大可访问内存索引 |
| gas  | 执行可用的 gas |
| address  | 当前合约 / 执行上下文的地址 |
| balance(a)  | 地址 a 的余额，以 wei 为单位 |
| caller  | 调用发起者（不包括 delegatecall） |
| callvalue  | 随调用发送的 Wei 的数量 |
| calldataload(p)  | 位置 p 的调用数据（32 字节） |
| calldatasize  | 调用数据的字节数大小 |
| calldatacopy(t, f, s)  | 从调用数据的位置 f 的拷贝 s 个字节到内存的位置 t |
| codesize  | 当前合约 / 执行上下文地址的代码大小 |
| codecopy(t, f, s)  | 从代码的位置 f 开始拷贝 s 个字节到内存的位置 t |
| extcodesize(a)  | 地址 a 的代码大小 |
| extcodecopy(a, t, f, s)  | 和 codecopy(t, f, s) 类似，但从地址 a 获取代码小 |
| create(v, p, s)  | 用 mem[p…(p + s)) 中的代码创建一个新合约、发送 v wei 并返回 新地址 |
| call(g, a, v, in, insize, out, outsize)  | 使用 mem[in…(in + insize)) 作为输入数据， 提供 g gas 和 v wei 对地址 a 发起消息调用， 输出结果数据保存在 mem[out…(out + outsize))， 发生错误（比如 gas 不足）时返回 0，正确结束返回 1 |
| callcode(g, a, v, in, insize, out, outsize)  | 与 call 等价，但仅使用地址 a 中的代码 且保持当前合约的执行上下文 |
| delegatecall(g, a, in, insize, out, outsize)  | 与 callcode 等价且保留 caller 和 callvalue |
| staticcall(g, a, in, insize, out, outsize)  | 与 call(g, a, 0, in, insize, out, outsize) 等价 但不允许状态修改 |
| return(p, s)  | 终止运行，返回 mem[p…(p + s)) 的数据 |
| revert(p, s)  | 终止运行，撤销状态变化，返回 mem[p…(p + s)) 的数据 |
| selfdestruct(a)  | 终止运行，销毁当前合约并且把资金发送到地址 a |
| invalid  | 以无效指令终止运行 |
| log0(p, s)  | 以 mem[p…(p + s)) 的数据产生不带 topic 的日志 |
| log1(p, s, t1)  | 以 mem[p…(p + s)) 的数据和 topic t1 产生日志 |
| log2(p, s, t1, t2)  | 以 mem[p…(p + s)) 的数据和 topic t1、t2 产生日志 |
| log3(p, s, t1, t2, t3)  | 以 mem[p…(p + s)) 的数据和 topic t1、t2、t3 产生日志 |
| log4(p, s, t1, t2, t3, t4)  | 以 mem[p…(p + s)) 的数据和 topic t1、t2、t3 和 t4 产生日志 |
| origin  | 交易发起者地址 |
| gasprice  | 交易所指定的 gas 价格 |
| blockhash(b)  | 区块号 b 的哈希 - 目前仅适用于不包括当前区块的最后 256 个区块 |
| coinbase  | 当前的挖矿收益者地址 |
| timestamp  | 从当前 epoch 开始的当前区块时间戳（以秒为单位） |
| number  | 当前区块号 |
| difficulty  | 当前区块难度 |
| gaslimit  | 当前区块的 gas 上限 |

### 字面常量
你可以直接键入十进制或十六进制符号来作为整型常量使用，这会自动生成相应的 PUSHi 指令。 下面的代码将计算 2 加 3（等于 5），然后计算其与字符串 “abc” 的按位与。字符串在存储时为左对齐，且长度不能超过 32 字节。

`assembly { 2 3 add "abc" and }`

### 函数风格
你可以像使用字节码那样在操作码之后键入操作码。例如，把 3 与内存位置 0x80 处的数据相加就是`3 0x80 mload add 0x80 mstore`由于通常很难看到某些操作码的实际参数是什么，所以 Solidity 内联汇编还提供了一种“函数风格”表示法，同样功能的代码可以写做`mstore(0x80, add(mload(0x80), 3))`函数风格表达式内不能使用指令风格的写法，即 1 2 mstore(0x80, add) 是无效汇编语句， 它必须写成 mstore(0x80, add(2, 1)) 这种形式。对于不带参数的操作码，括号可以省略。

注意，在函数风格写法中参数的顺序与指令风格相反。如果使用函数风格写法，第一个参数将会位于栈顶。

### 访问外部变量和函数
通过简单使用它们名称就可以访问 Solidity 变量和其他标识符。对于内存变量，这会将地址而不是值压入栈中。 存储变量是不同的，因为存储变量的值可能不占用完整的存储槽，因此其“地址”由存储槽和槽内的字节偏移量组成。 为了获取变量 x 所使用的存储槽，你可以使用 x_slot，并用的 x_offset 获取其字节偏移量。

在赋值语句中（见下文），我们甚至可以使用 Solidity 局部变量来赋值。

对于内联汇编而言的外部函数也可以被访问：汇编会将它们的入口标签（带有虚拟函数解析）压入栈中。Solidity 中的调用语义为：

调用者压入 return label、arg1、arg2、…、argn

被调用方返回 ret1、ret2、…、retm

这个特性使用起来还是有点麻烦，因为在调用过程中堆栈偏移量发生了根本变化，因此对局部变量的引用将会出错。
```
pragma solidity ^0.5.0;

contract C {
    uint b = 10;
    function f(uint x) public view returns (uint r) {
        assembly {
            r := mul(x, sload(b_slot)) // 因为偏移量为 0，所以可以忽略
        }
    }
}
```

如果你访问一个实际数据位数小于 256 位的数据类型（比如 uint64、address、bytes16 或 byte）， 不要对这种类型经过编码后未使用的数据位上的数值做任何假设。尤其是不要假设它们肯定为 0。 安全起见，在某个上下文中使用这种数据之前，请一定先将其数据清空为 0，这非常重要： uint32 x = f(); assembly { x := and(x, 0xffffffff) /* now use x */ } 要清空有符号类型，你可以使用 signextend 操作码。


### 汇编局部变量声明
你可以使用 let 关键字来声明只在内联汇编中可见的变量，实际上只在当前的 {...} 块中可见。 下面发生的事情应该是：let 指令将创建一个为变量保留的新数据槽，并在到达块末尾时自动删除。 你需要为变量提供一个初始值，它可以只是 0，但它也可以是一个复杂的函数风格表达式。
```
pragma solidity ^0.5.0;

contract C {
    function f(uint x) public view returns (uint b) {
        assembly {
            let v := add(x, 1)
            mstore(0x80, v)
            {
                let y := add(sload(v), 1)
                b := y
            } // y 会在这里被“清除”
            b := add(b, v)
        } // v 会在这里被“清除”
    }
}
```

### 赋值
可以给汇编局部变量和函数局部变量赋值。请注意：当给指向内存或存储的变量赋值时，你只是更改指针而不是数据。

有两种赋值方式：函数风格和指令风格。对于函数风格赋值（变量 := 值），你需要在函数风格表达式中提供一个值，它恰好可以产生一个栈里的值； 对于指令风格赋值（=: 变量），则仅从栈顶部获取数据，指令风格的赋值方式官方已经不推荐使用。对于这两种方式，冒号均指向变量名称。赋值则是通过用新值替换栈中的变量值来实现的。
```
{
    let v := 0 // 作为变量声明的函数风格赋值
    let g := add(v, 2)
    sload(10)
    =: v // 指令风格的赋值，将 sload(10) 的结果赋给 v
}
```

### 条件判断与循环语句
#### If关键字
if 语句可以用于有条件地执行代码，且没有“else”部分；如果需要多种选择，你可以考虑使用“switch”（见下文）。
```
{
    if eq(value, 0) { revert(0, 0) }
}
```
代码主体的花括号是必需的。

#### Switch关键字
作为“if/else”的非常初级的版本，你可以使用 switch 语句。它计算表达式的值并与几个常量进行比较。选出与匹配常数对应的分支。 与某些编程语言容易出错的情况不同，控制流不会从一种情形继续执行到下一种情形。我们可以设定一个 fallback 或称为 default 的默认情况。
```solidity
{
    let x := 0
    switch calldataload(4)
    case 0 {
        x := calldataload(0x24)
    }
    default {
        x := calldataload(0x44)
    }
    sstore(0, div(x, 2))
}
```
Case 列表里面不需要大括号，但 case 主体需要。

#### For关键字循环
汇编语言支持一个简单的 for-style 循环。For-style 循环有一个头，它包含初始化部分、条件和迭代后处理部分。 条件必须是函数风格表达式，而另外两个部分都是语句块。如果起始部分声明了某个变量，这些变量的作用域将扩展到循环体中（包括条件和迭代后处理部分）。

下面例子是计算某个内存区域中的数值总和。
```
{
    let x := 0
    for { let i := 0 } lt(i, 0x100) { i := add(i, 0x20) } {
        x := add(x, mload(i))
    }
}
```
For 循环也可以写成像 while 循环一样：只需将初始化部分和迭代后处理两部分留空。
```
{
    let x := 0
    let i := 0
    for { } lt(i, 0x100) { } {     // while(i < 0x100)
        x := add(x, mload(i))
        i := add(i, 0x20)
    }
}
```

### 函数

汇编语言允许定义底层函数。底层函数需要从栈中取得它们的参数（和返回 PC），并将结果放入栈中。调用函数的方式与执行函数风格操作码相同。

函数可以在任何地方定义，并且在声明它们的语句块中可见。函数内部不能访问在函数之外定义的局部变量。这里没有严格的 return 语句。

如果调用会返回多个值的函数，则必须使用 a，b：= f(x) 或 let a，b：= f(x) 的方式把它们赋值到一个元组。

下面例子通过平方和乘法实现了幂运算函数。
```
{
    function power(base, exponent) -> result {
        switch exponent
        case 0 { result := 1 }
        case 1 { result := base }
        default {
            result := power(mul(base, base), div(exponent, 2))
            switch mod(exponent, 2)
                case 1 { result := mul(base, result) }
        }
    }
}
```

### 注意事项
内联汇编语言看起来像高级语言，但实际上它是非常低级的编程语言。函数调用、循环、if 语句和 switch 语句通过简单的重写规则进行转换， 然后，汇编程序为你做的唯一事情就是重新组织函数风格操作码、管理 jump 标签、计算访问变量的栈高度，还有在到达语句块末尾时删除局部汇编变量的栈数据。 特别是对于最后两种情况，汇编程序仅会按照代码的顺序计算栈的高度，而不一定遵循控制流程；了解这一点非常重要。此外，swap 等操作只会交换栈内的数据，而不是变量位置。

### Solidity 惯例
与 EVM 汇编语言相比，Solidity 能够识别小于 256 位的类型，例如 uint24。为了提高效率，大多数算术运算只将它们视为 256 位数字， 仅在必要时才清除未使用的数据位，即在将它们写入内存或执行比较之前才会这么做。这意味着，如果从内联汇编中访问这样的变量，你必须先手工清除那些未使用的数据位。

Solidity 以一种非常简单的方式管理内存：在 0x40 的位置有一个“空闲内存指针”。如果你打算分配内存，只需从此处开始使用内存，然后相应地更新指针即可。

内存的开头 64 字节可以用来作为临时分配的“暂存空间”。“空闲内存指针”之后的 32 字节位置（即从 0x60 开始的位置）将永远为 0，可以用来初始化空的动态内存数组。

在 Solidity 中，内存数组的元素总是占用 32 个字节的倍数（是的，甚至对于 byte[] 都是这样，只有 bytes 和 string 不是这样）。 多维内存数组就是指向内存数组的指针。动态数组的长度存储在数组的第一个槽中，其后才是数组元素。

## 独立汇编

内联汇编描述的汇编语言也可以单独使用，实际上，计划是将其用作Solidity编译器的中间语言。在这种意义下，它试图实现以下几个目标：

1、即使代码是由 Solidity 的编译器生成的，用它编写的程序应该也是可读的。 2、从汇编到字节码的翻译应该尽可能少地包含“意外”。 3、控制流应该易于检测，以帮助进行形式化验证和优化。

为了实现第一个和最后一个目标，汇编提供了高级结构：如 for 循环、if 语句、switch 语句和函数调用。 应该可以编写不使用明确的 SWAP、DUP、JUMP 和 JUMPI 语句的汇编程序，因为前两个混淆了数据流，而最后两个混淆了控制流。 此外，形式为 mul(add(x, y), 7) 的函数风格语句优于如 7 y x add mul 的指令风格语句，因为在第一种形式中更容易查看哪个操作数用于哪个操作码。

第二个目标是通过采用一种非常规则的方式来将高级高级指令结构便以为字节码。 汇编程序执行的唯一非局部操作是用户自定义标识符（函数、变量、…）的名称查找，它遵循非常简单和固定的作用域规则并从栈中清除局部变量。
