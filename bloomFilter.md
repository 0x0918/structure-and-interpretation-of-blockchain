&emsp;&emsp;要判断一个元素是不是在一个集合里，比较容易想到的方法是用数组，链表这样的数据结构把元素保存起来，然后依次比较来确定。

&emsp;&emsp;但是随着集合的变大，上面的这种方法就面临几个问题，首先比较的速度随着数据量的增加而变慢，其次存储集合的空间也越来越大。

&emsp;&emsp;为了解决上面的问题，就引入了`布隆过滤器（Bloom Filter）`

### 布隆过滤器原理
&emsp;&emsp;布隆过滤器的原理就是当一个元素被加入到集合的时候，用`K`个`Hash`函数将元素映射到一个`位图`中的`K`个点，并且把这个点的值设置为`1`，在每次检索的时候我们看一下这个点是不是都是`1`就知道集合中有没有这个元素了。

&emsp;&emsp;这样说可能比较抽象，举个例子：

&emsp;&emsp;我们假设`K`是`2`，有`Hash1`和`Hash2`两个哈希函数
```
Hash1 = n%3
Hash2 = n%8
```

&emsp;&emsp;然后我们创建一个名叫`bitMap`长度是`20`的`位图`
```
bitMap=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

&emsp;&emsp;这个时候，我们要将7，存入到这个集合中
```
n = 7
```
&emsp;&emsp;分别用`Hash1`和`Hash2`计算`n`哈希后的值
```
Hash1  ->  1
Hash2  ->  7
```
&emsp;&emsp;我们把`bitMap`对应的值置为1，从0开始
```
bitMap=[0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```
&emsp;&emsp;这样下次我们来查找`7`在不在这个集合的时候就可以用`Hash1`和`Hash2`计算完以后在`bitMap`集合中查找对应位置是否都是`1`，如果都是`1`则一定在集合中。

&emsp;&emsp;如果再在集合中插入13
&emsp;&emsp;分别用`Hash1`和`Hash2`计算`n`哈希后的值
```
n = 13
Hash1  ->  1
Hash2  ->  5
```
&emsp;&emsp;我们把`bitMap`对应的值置为1，从0开始
```
bitMap=[0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```
&emsp;&emsp;这个时候我们发现`1`被映射到了两次，但是并不影响我们在集合`[7, 13]`中快速判断7或者13是否在其中。

&emsp;&emsp;但是当插入的数据量大幅提升的时候，甚至`bitMap`全部被置为`1`的时候问题就很严重，误识率就非常高，这个也是根据不同场景实现布隆过滤器所要考虑的问题。

&emsp;&emsp;尽管有这样的问题，但是仍然不能掩盖布隆过滤器的`空间利用率`和`查询时间`远超其他算法，插入数据和查询数据的时间复杂度都是`O(k)`。

&emsp;&emsp;布隆过滤器还有一个很重要的特点是不支持删除操作，这个也很好理解，从上面的例子中可以看到，位图的有些位置被映射了两次，如果删除则会造成误识。

### 应用场景
&emsp;&emsp;比较典型的应用场景就是检查垃圾邮箱的地址，比如我建立了一个垃圾邮件的布隆过滤器，当新邮件到来的时候我要快速的判断这封邮件是不是垃圾邮件。

&emsp;&emsp;还可以用来判断一个URL是不是恶意链接等等。

&emsp;&emsp;以太坊大量的用到了布隆过滤器，用来定位查找日志等。
