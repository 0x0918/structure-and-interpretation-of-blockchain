# 区块链核心数据结构

在区块链中，交易被用来驱动链上状态的变更，在比特币中通过交易驱动UTXO模型中比特币的转移，在以太坊中通过交易驱动账户模型中合约状态的变更，无论是这个过程是否成功，我们都需要能查询到这个过程的发起方，中间变更的状态以及最后变更得到的结果。这就好比一笔银行转账，需要明确转移的金额，支付和收款的账户，接着需要明确双方账户中的余额是否变更成功，最后会得到张回执单，可以通过回执内容查到这笔交易的信息。转账完成后，这些信息并不会消失，而是会持久保存，可能是为了方便客户查询，可能是为了接受监管，但无论怎样这些信息都需要持久的保存下来。

对于银行而言，这些数据都是由中心化的数据中心来存储，数据中心需要高昂的费用和专业的工程师来维持运作，设置了非常高的门槛，但是对于区块链来说，在保存这些数据的同时既要足够的去中心化（每个节点都要保存一份副本），还要降低运行的硬件成本，让更多的人能参与其中来保证系统的可靠性。为了实现这些目标，就需要为区块链平台设计一种高效的数据结构来满足这个需求。

要设计一个高效的数据结构来保存这些数据，先聚焦问题归纳一下要保存数据特点。
- 交易数据，一般而言一笔交易只有几k的大小，部署合约的交易会大一些会有十几k到几十k不等，但是部署合约的交易量很少。
- 合约状态，合约中storage标识的数据需要持久化，这些数据只有几b大，但是每个合约都可能有很多，数量大但是体积非常小。
- 回执数据，回执数据与交易数据像对应，一笔交易产生一个回执，体积有几k大小。

归纳一下需要存储的数据就会发现一些共性，数量非常多，体积非常小，既要保存也要可以查询。

将查询的场景在拓展一下，考虑这样一种情况，A收到来自B的一个通知，B声称他已经从某某账户中汇款一定数额的钱给了A。去中心方式下，没有任何人能证明B的可靠。接到这一通知，A如何能判断B所说的是真的呢？

如果A想本人亲自验证这笔交易，首先，A要遍历区块链账本，定位到B的账户上，这样才能查看B所给的账户支票上是否曾经有足够的金额；接下来，A要遍历后续的所有账本，看B是否已经支出了这个账户支票上的钱给别人(是否存在双花欺骗）；然后还要验证脚本来判断B是否拥有该账户的支配权。这一过程要求A必须得到完整的区块链才行。

以太坊中的完整区块大小以及几十G，并且这个大小还在不断的增长，要求完整区块数据显然提高了区块链的使用门槛，为了解决这个问题又需要对数据结构进行精心的设计。

为了解决所面临的问题，先从几个简单的数据结构开始。

## 默克尔树
默克尔树(Merkle Tree)属于二叉树的一种，由一个根节点，一组中间节点和一组叶子节点组成。

默克尔树首先计算叶子节点的hash值，然后将相邻两个节点的哈希进行合并，合并完成后计算这个字符串的哈希值，直到根节点为止，如果是单个节点，可以复制单节点的哈希，然后合并哈希再重复上面的过程。

![](https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_6/6_1.png?raw=true)

这种数据结构的特点非常的明显，可以高效安全的验证数据结构的内容，当树的内容发生改变时，计算得到的根哈希就会不同，比如p2p网络分块下载文件的时候，可以用来快速校验下载到的数据是否完整，是否遭到破坏，先传递一个很小的根哈希，接着分块传输数据，当数据传输完成后计算根哈希，比较与之前得到的根哈希是否一致，如果一致则表示数据传输没有出错。

## 默克尔证明

假设有这样一种场景需要用到比特币支付，支付完成以后我需要向对方证明这笔交易已经写到区块中了，比较容易想到的办法就是拿到打包交易的对应区块，然后对比区块中的所有交易来确认是否已经被打包其中。
但是在比特币或者以太坊的场景下，一个区块大概有两三千笔交易，一个交易又包含若干字段，如果逐一比较交易不仅速度慢，而且不安全，因为拿单一的区块你无法知道拿到的块的真伪。
而默克尔证明提供了一种仅需链中全量区块头信息就可以证明交易是否存在某一区块中的方法。
> 全量保存区块头是为了保证安全性，而且区块头很小，非常适合在一些移动设备存储。

默克尔证明基于默克尔树。

![](https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_6/6_2.png?raw=true)


如果我们知道了根哈希，也就是紫色的这个节点包含的值，需要证明红色的节点包含的`Peach`是否在这个集合中，仅需要提供绿色节点包含的值就可以。
我们可以计算出`Peach`的哈希值，然后依次与绿色节点包含的哈希值两两计算哈希，最终就可以得到根哈希，根哈希一致则证明`Peach`在这个区块中。

### 优势
- 无需知道其他节点的值是什么就可以证明特定节点是否在集合中。
- 仅存储默克尔证明消耗很小的空间。
- 判断一笔交易是否在区块中的消耗很低。

### 场景
轻节点只包含区块头，也就是只有交易树的根哈希值，当A需要向轻节点证明一笔交易已经打包到指定区块时，只需要提供这笔交易和对应路径上的哈希值即可，这样轻节点就可以在不保存区块体的情况下证明了这笔交易已经上链不可更改了。

有了默克尔树和默克尔证明这两种工具以后，解决了计算能力弱的设备证明交易上链的需求，也解决了数据完整性的需要。但是并没有解决具体的数据存储需要采用什么样的存储结构，比如采取数组，链表，哈希表或者是树结构。

比较朴素的想法是采用哈希表来进行存储，在常量个时间就可以实现数据的查询，但是这种方式并不适合与区块链场景，在区块链场景中，每一笔交易影响状态变更的账户数都是非常少的，如果维护一个全局的哈希表，每一次状态的变更都需要生成全量的根哈希，大量的重复计算会导致性能急剧下降，数组，链表也都存在相同的问题。

可以看到重复计算是导致性能下降的罪魁祸首，那解决这个问题的方法就是减少重复计算。