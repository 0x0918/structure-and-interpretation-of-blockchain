Solidity是一种静态类型的编程语言，用于开发在EVM上运行的智能合约。 Solidity被编译为可在EVM上运行的字节码。借由Solidity，开发人员能够编写出可自主运行其商业逻辑的应用程序，该程序可被视为一份具权威性且永不可悔改的交易合约。对已具备程序编辑能力的人而言，编写Solidity的难易度就如同编写一般的编程语言。

Gavin Wood最初在规划Solidity语言时引用了ECMAScript的语法概念，使其对现有的Web开发者更容易入门；与ECMAScript不同的地方在于Solidity具有静态类型和可变返回类型。而与当前其他EVM目标语言（如Serpent和Mutan）相比，其重要的差异在于Solidity具有一组复杂的成员变量使得合约可支持任意层次结构的映射和结构。Solidity也支持继承，包含C3线性化多重继承。 另外还引入了一个应用程序二进制接口（ABI），该接口（ABI）可在单一合同中实现多种类型安全的功能。

Remix是一个开源的用于Solidity智能合约开发的Web端IDE，提供基本的编译、部署至本地或测试网络、执行合约等功能。Solidity是Ethereum官方设计和支持的程序语言，专门用于编写智能合约，本书中的所有例子都已经在Remix测试通过。

Remix既可以本地部署，也可以直接使用官方部署好的环境，地址是：`https://remix.ethereum.org`.

## 跨合约调用
以太坊为了避免了合约成为数据孤岛，增加了跨合约调用的支持，简言之就是一个合约可以调用另一个合约，跨合约调用大大增强了智能合约的互操作性，简化了开发成本。同时扩展了业务的想象空间。

跨合约调用必须是确定性的静态调用——在运行前即知晓被调用合约的地址，且调用结果是确定性的。

Solidity 中用`call`，`callcode`，`delegatecall`这三个函数来进行跨合约的调用。三者又有所区别。

### call vs callcode
call 和 callcode 的区别在于：代码执行的上下文环境不同。具体来说，call 修改的是被调用者的storage，而 callcode 修改的是调用者的storage。换用另外一种说法是，callcode 通过调用其他的智能合约的函数，来修改自己的智能合约的变量。而 call 通过调用其他的智能合约的函数，来修改被调用智能合约的状态。如下图所示：

![](https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_4/4_1.png?raw=true)

### callcode vs delegatecall
callcode 已经被官方推荐使用 delegatecall 替代了。如果使用，编译器会提示`Warning: "callcode" has been deprecated in favour of "delegatecall"`。

callcode 与 delegatecall 都是通过调用其他的智能合约的函数，来修改自己的智能合约的变量。区别就是msg.sender不同。具体来说，delegatecall 会一直使用原始调用者的地址，而 callcode 不会。如下图所示：

![](https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_4/4_2.png?raw=true)


上面的 callcode 跟 delegatecall 都是通过调用其他的智能合约的函数，来修改自己的智能合约的变量。如果自己合约中不存在这个变量，Solidity是怎么处理的呢？Solidity 会智能地新建一个变量。但实际是在一个未定义的位置存储了这个新建的变量的值，智能合约根本没法访问到。



## 作用域
变量无论在函数内什么位置定义，其作用域均为整个函数，而非大多数据语言常见的块级作用域。下面的例子会报错`DeclarationError: Undeclared identifier.`。

```
pragma solidity ^0.5.0;

contract ScopeErr{
  function f() pure public returns (uint8) {
    { uint8 a = 0;}

    return a;
  }
}

```
上例中，由于变量作用域不同，导致a在函数里面并没有被声明，在返回的时候就会报错。

我们来看一个稍微隐蔽点的例子：
```
pragma solidity ^0.5.0;

contract FunctionScope{
  function f() public view returns (uint8){
    for(var i = 0; i < 10; i++){
      //do sth
    }
    return i;
  }
}

```
读者可以试想一下上述代码能否编译通过呢。
答案是不可以的，原因就是因为i变量虽然是在for循环中被定义，但它的的作用域不是整个函数，但是在函数内的任何位置均可以访问到这个变量。


