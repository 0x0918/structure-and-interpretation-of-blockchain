# 默克尔树
默克尔树(Merkle Tree)属于二叉树的一种，由一个根节点，一组中间节点和一组叶子节点组成。默克尔树有两个很重要的特点，快速比较大量数据是否一致和快速定位大量数据中哪些数据发生了变化。比特币和以太坊基于默克尔树的这两个特点为其轻节点提供默克尔证明。

默克尔树首先计算叶子节点的hash值，然后将相邻两个节点的哈希进行合并，合并完成后计算这个字符串的哈希值，直到根节点为止，如果是单个节点，可以复制单节点的哈希，然后合并哈希再重复上面的过程。

![](https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_6/6_1.png?raw=true)

这种数据结构的特点非常的明显，可以高效安全的验证数据结构的内容，当树的内容发生改变时，计算得到的根哈希就会不同，比如p2p网络分块下载文件的时候，可以用来快速校验下载到的数据是否完整，是否遭到破坏，先传递一个很小的根哈希，接着分块传输数据，当数据传输完成后计算根哈希，比较与之前得到的根哈希是否一致，如果一致则表示数据传输没有出错。

## 默克尔证明
假设有这样一种场景需要用到比特币支付，支付完成以后我需要向对方证明这笔交易已经写到区块中了，比较容易想到的办法就是拿到打包交易的对应区块，然后对比区块中的所有交易来确认是否已经被打包其中。

在比特币或者以太坊的场景下，一个区块大概有两三千笔交易，一个交易又包含若干字段，如果逐一比较交易不仅速度慢，而且不安全，因为拿单一的区块是无法知道拿到的块的真伪。

默克尔证明提供了一种仅需链中全量区块头信息就可以证明交易是否存在某一区块中的方法。
> 全量保存区块头是为了保证安全性，而且区块头很小，非常适合在一些移动设备存储。

默克尔证明基于默克尔树。

![](https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_6/6_2.png?raw=true)


如果我们知道了根哈希，也就是紫色的这个节点包含的值，需要证明红色的节点包含的`Peach`是否在这个集合中，仅需要提供绿色节点包含的值就可以。
我们可以计算出`Peach`的哈希值，然后依次与绿色节点包含的哈希值两两计算哈希，最终就可以得到根哈希，根哈希一致则证明`Peach`在这个区块中。

### 优势
- 无需知道其他节点的值是什么就可以证明特定节点是否在集合中。
- 仅存储默克尔证明消耗很小的空间。
- 判断一笔交易是否在区块中的消耗很低。

### 场景
轻节点只包含区块头，也就是只有交易树的根哈希值，当A需要向轻节点证明一笔交易已经打包到指定区块时，只需要提供这笔交易和对应路径上的哈希值即可，这样轻节点就可以在不保存区块体的情况下证明了这笔交易已经上链不可更改了。

有了默克尔树和默克尔证明这两种工具以后，解决了计算能力弱的设备证明交易上链的需求，也解决了数据完整性的需要。但是并没有解决具体的数据存储需要采用什么样的存储结构，比如采取数组，链表，哈希表或者是树结构。

比较朴素的想法是采用哈希表来进行存储，在常量个时间就可以实现数据的查询，但是这种方式并不适合与区块链场景，在区块链场景中，每一笔交易影响状态变更的账户数都是非常少的，如果维护一个全局的哈希表，每一次状态的变更都需要生成全量的根哈希，大量的重复计算会导致性能急剧下降，数组，链表也都存在相同的问题。

可以看到重复计算是导致性能下降的罪魁祸首，那解决这个问题的方法就是减少重复计算。