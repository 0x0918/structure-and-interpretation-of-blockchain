# 区块结构

区块由上一个区块的散列值，若干条交易，一个调节数等元素构成，节点通过共识维持区块的连续性以此来保证区块链的安全性。其中区块最为重要的特点就是交易的集合，公链或者联盟链将交易打包成区块以后进行持久化存储。

比特币中的区块有体积为`1M`，一笔交易的大小在`250 Bytes`左右，意味着比特币系统中一个区块可以容纳2500到3000笔左右的交易。区块大小并没有具体的限制，还是根据不同的区块链平台和应用场景来配置，在比特币发展的历史上也曾因区块大小的设置产生过很多分歧。

以太坊中的区块大小并不固定，平均大小约为0.02M（平均出块时间为15秒），其背后的原因，在于它采用了完全不同于比特币的做法。

比特币的转帐交易是统一格式，可以用固定的区块大小来规范。以太坊则不同，V神（以太坊的创立者）将区块链视为世界计算机，在比特币基础上，以太坊实现了智能合约，这就意味着，除了和比特币有同样的转帐功能外，以太坊网络中更多的是要为大量程序提供运算服务。

举个例子，对于转帐交易类事务，以太坊网络的处理是相对一致的；但是对于合约调用而言，需要调用不同的合约方法所需的参数不同，这就导致很难从固定交易大小的角度来约束区块打包的交易数量。

以太坊网络中不同的事务，所需要的计算成本各不相同，并且以太坊明确了每笔操作会有个最低算力消耗值，而智能合约的算力消耗量则在最低消耗值基础上，还需要加上所有代码执行的算力。实际消耗的算力只有在实际使用时才能确认。

如果需要用一个相对固定的参数来规范以太坊区块的话，最直观的就是固定每个区块中所包含的算力了。这个值由矿工在每个区块中的`GAS LIMIT`(单位：gas)参数来表示，每个交易提交时也会有算力需求（单位：gas），乘以算力gas的价格（单位：gwei/gas)，就是交易成本了（单位：gwei，gwei和ETH类似于比特币里的 聪 和BTC的关系：每 eth = 10^9 gwei）。
> 2020年2月2日以太坊每个区块的GAS LIMIT大约1千万左右。

提交每笔交易时，需要附加愿意付出的最多成本，矿工在打包时，会遵循以下规则：
- 利益导向——哪笔交易给的酬劳高，会优先打包谁的，直到区块中包含的算力值(gas limit)消耗殆尽；
- 多退少不补——按实际算力收取费用，但如果给的不够，打包时则不会将计算结果提交到链上，费用也会全部收取（每笔事务的最低算力消耗值则为21000gas）。
- 在理解了上述规则后，扩容问题的解决就简单了：为了避免出现比特币类似的区块扩容争议，以太坊协议允许矿工每次可以将上个区块BGL值调整正负0.0976%（=1/1024 ），按平均每15秒出块的频率，以快速满足网络上快速变化的计算需求。

因此，在面对突来的交易激增时，以太坊表现出了较好的灵活性，比如在2017年6月29日，因ICO原因，交易量激增，以太坊在不到2个小时内，就实现了33%的增长。

以太坊网络每个区块中包含算力从最早的3百多万，到目前基本稳定在1千万gas左右。在能提供的算力增长时，如有足够的交易能消耗完，自然矿工会得到更多收益，但也需要矿工付出更多成本——更大的宽带、更快的计算能力，所以这个过程虽然不需要多方争议，但也受限于物理性能，客观上不会一蹴而就。

可以看到与比特币区块中以转账交易为核心的区块打包思路不同，以太坊设计了一套以区块链平台计算能力为核心的区块打包策略，归根到底还是二者的愿景不同，比特币希望成为数字黄金，以太坊则希望成为世界计算机。


看一下以太坊的区块结构。

![](https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_6/6_12.png?raw=true)

从上图可以看到，区块由两部分组成，分别是区块头（header）和区块体（body）两部分。

## 区块头（header）

区块头存储了区块的元信息，用来对区块内容进行一些标识，校验，说明等。区块头里字段分为两部分区块头和区块体。

### 通用字段
- ParentHash： 父区块的哈希值。
- StateRoot：世界状态的哈希，stateDB的RLP编码后的哈希值。
- TxHash（transaction root hash）：交易字典树的根哈希，由本区块所有交易的交易哈希算出。
- ReceptHash：收据树的哈希。
- Time：区块产生出来的Unix时间戳。
- Number：区块号。
- Bloom：布隆过滤器，快速定位日志是否在这个区块中。

### 公链场景
- Coinbase：挖出这个块的矿工地址，因为挖出块所奖励的ETH就会发放到这个地址。
- Difficulty：当前工作量证明（Pow）算法的复杂度。
- GasLimit: 每个区块Gas的消耗上线。
- GasUsed：当前区块所有交易使用的Gas之和。
- MixDigest: 挖矿得到的Pow算法证明的摘要，也就是挖矿的工作量证明。
- nonce：挖矿找到的满足条件的值。
- Uncle：叔块是和以太坊的共识算法相关。

一般而言一个类以太坊的联盟链是需要上面介绍的通用字段的，但是也不绝对，还可能与选择的共识算法，隐私保护策略，设计偏好有关。

## 区块体（Body）

区块体包括这个区块打包的所有交易，在一些链的设计中，并不像以太坊区分header和body，而是整合在一起。

### 区块存储
以太坊在存储区块的时候，区块头和区块体其实是分开存储的，其实也很容易理解，分开存储可以提供更多的灵活性，比如不用保存全部区块数据的轻节点。

#### 区块头存储
以太坊通过如下方式将区块头转换成键值对存储在LevelDB中；
```
headerPrefix + num + hash  -> rlp(header)
Tips: num是以大端序的形式转换成bytes的，其中headerPrefix的值是 []byte("h")
```

#### 区块体存储
区块体的存储方式也是类似；
```
bodyPrefix + num + hash -> rlp(block)
Tips: num是以大端序的形式转换成bytes的，其中bodyPrefix的值是[]byte("b")
```

## 潜在问题
假设在一个联盟链的场景下，采用了BFT类的算法，有一个重量级的业务跑在上面，日积月累产生了大量的数据，是否会出现LevelDB的读写性能大幅下降拖慢系统的响应速度？单机存储无法满足需要？存储了大量的不会使用的历史数据？

在联盟链的场景下，由于共识速度的提升，导致出块速度也大幅提升，原本在公链场景下不存在的区块写入瓶颈，现在反而成了拖慢系统运行速度的重要因素了。

观察一下区块数据的存储就可以发现下面的这些特点；
- 区块数据只会增加；
- 无需对历史区块进行修改；
- 无需对区块数据进行复杂操作，比如聚合，运算等；

归纳一下就是顺序写，随机读和迭代（Iterator），针对这些特点Hyperledger Fabric设计了基于文件的存储方式，在Fabric中区块数据是以一个个文件的形式存在。

```
chains
  |----mychannel
  |----|----blockfile_000000
index
  |----000001.log
  |----CURRENT
  |----LOCK
  |----LOG
  |----MANIFEST-000000
```
其中blockfile_000000是区块数据，index则是索引游标等元信息，这种方式速度很快，方便做数据归档，也可以避免像LevelDB等数据库数据越写越慢的问题，主流联盟链都是采用类似的方案。
