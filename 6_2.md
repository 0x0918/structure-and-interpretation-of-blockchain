# 字典树

为了解决数据变更需要计算全量哈希和乱序数据默克尔证明不一致的问题，引入了一种新的数据结构。
## 字典树（Trie）

Trie又称前缀树或字典树，是一种有序树，用于保存关联数据，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。

下图是一颗典型的前缀树；

![](https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_6/6_3.png?raw=true)

图中前缀树存储了一些字符串，蓝色的是关键字，存储的字符串由关键字组成。存储了"a", "to", "tea", "ted", "ten", "i", "in", "inn"。
前缀树有这些特点；
- 根节点不包含字符，其他节点各包含一个字符；
- 关键路径节点的字符连接起来为该节点所存储的数据；

> 关键路径就是每个节点有一个标志位，用来标记这个节点是否作为构成数据的一部分，上图中的，t, e 节点就不是关键路径。

Trie的核心思想就是用空间换时间，利用公共前缀缩小要比较的范围来达到快速查找的目的。

如果Trie树叶上的数据发生了变化，只需要计算树叶到根路径上的哈希即可，避免了全量的哈希计算，相较于哈希表的方式，牺牲了一定的查询速度，多浪费了一些空间，但是也避免了大量的计算。

虽然相较于哈希表，插入和查询速度有不足，但是trie的插入和查询的效率依然算是非常高效的，都是O(m)，m是插入或查询字符串的长度，同时trie也支持了对数据按照字典序排序，这也是哈希表所不具备的特点。

除此之外trie还在这些场景有广泛的应用；
- 但词频次统计。
- 字符串匹配。
- 字符串字典序排序。
- 前缀匹配，比如一些搜索框的自动提示。

## 压缩字典树

压缩字典树在字典树的基础之上做了一些优化，具体可以看下图；

![](https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_6/6_4.png?raw=true)

图中黑色的是关键路径，存储了字符串"abc"和"d"，但是明显可以看到压缩后的前缀树占用了更小的空间。