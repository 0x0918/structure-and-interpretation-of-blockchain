# Bucket Tree
MPT树的设计已经足够优秀，但是在超级账本中组织世界状态的时候没有使用MPT树，而是采用了`Bucket Tree`。软件工程中没有银弹可以一劳永逸的解决所有问题，在联盟链场景中MPT树就暴露了很多问题。

以太坊面临的挑战是在一个公链场景下，有很多的用户在上面部署使用调用智能合约，但是绝大部分合约在部署以后调用量是非常少的，合约的复杂度也有限。而以太坊为了支持如此多的合约和大量合约的状态采用了MPT树，尽管采用了像节点划分，多种编码方式的各种优化手段，但是MPT树仍然在复杂性和性能方面存在一些问题，成为制约区块链平台的性能瓶颈。这个性能瓶颈并不是在以太坊这个体系之中，而是在联盟链技术体系之下。

在联盟链场景之下，会发现节点数量变少了，合约数量变少了，共识机制的不同导致联盟链接收执行交易的数量大幅提升，合约状态的变更也非常频繁。联盟链一般来说被用来支持具体的业务，业务流程相对固定，也就导致了不会有大量的合约部署，调用。大量的交易集中在少数合约之间，这些合约的“热”度变的非常的高。

MPT树针对这种对少量合约调用非常频繁的场景非常的乏力，当整条链只是为少量的合约服务时，MPT树就会成为性能瓶颈，这个时候超级账本采用了另一种数据结构来解决这个问题。

`Bucket Tree`拓展了哈希表的概念，引入了一个桶（bucket），也就是哈希桶，其结构如下图所示:

![](https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_6/6_10.jpg?raw=true)

KEY2和KEY3映射到相同的152号桶里。

Bucket tree在扩展哈希表的同时，又在哈希表上建立了默克尔树。

![](https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_6/6_11.jpg?raw=true)

哈希表由一系列的哈希桶（bucket）组成，每个桶中存储着若干被散列到该桶中的数据项（entry）所以数据项按序排列，每一个哈希桶有一个哈希值来标识整个桶，该哈希值是桶内所有数据通过哈希计算所得。相当于将原来需要全量计算的哈希表拆分成了一个接一个的子哈希表，这样当数据发生变化的时候缩小了需要计算哈希值的数据范围。

除了底层的哈希表外，上层是一系列的默克尔树节点，一个默克尔树节点对应着下层的N个哈希桶或者默克尔树节点，这个N也称作默克尔树的聚合度。

## 如此设计的目的：
通过这样的设计达到了两个目的，利用默克尔树的特点，使每次树状态改变，重新计算哈希的代价最小；利用哈希表进行底层数据的维护，使得数据项均匀分布；最终我们依然可以利用默克尔树根来快速感知世界状态的变更。

例如上图中，一条新的数据项entry5插入，该数据项被散列到POS为1的桶中。该桶，即从该桶至根节点上所有的节点被标为粉红色，即为脏节点。仅对这些脏节点进行哈希重计算，便可得到一个新的哈希值用来代表新的树状态。

由于bucket tree是一棵固定大小的树（即底层的哈希表容量在树初始化之后，就无法更改了），随着数据量的增大，采用散列函数将所有的数据项进行均匀散列可以避免数据聚集的情况发生。

## 重要参数
Bucket tree有两个重要的可调参数；

- capacity：表示哈希表的容量，该值越大，整课树所能容纳的数据项个数就越多，在聚合程度不变的前提下，树越高，从叶子节点到根节点的路径越长，哈希计算次数也越多。
- aggreation：表示一个父节点对应的孩子节点的个数，该值越大，表示树的收敛速度越快，在哈希表容量不变的前提下，树更低，从叶子节点到根节点路径越短，哈希计算次数也越少。但是每个默克尔树节点的size就越大，增加磁盘IO开销。

超级账本在实现Bucket tree的时候也采用了一些优化手段，比如当有比较多数据变更的时候，非常容易散列到不同bucket，这个时候可以并行计算新bucket的哈希值，加速构建默克尔树，如果Bucket tree树比较大，并且用数据库来存储的话，加上读cache可以显著的提升性能。超级账本结合具体的应用场景对数据结构通过改造优化极大的提高了系统的性能，其实很多时候需要把握每个数据结构在区块链系统中解决了哪些，高效的解决这些问题就可以了，并不需要拘泥于采用字典树，MPT树，默克尔树或者是Bucket tree。
