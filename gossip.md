当我们通过一个密码体系可以构建两个节点的安全通信后，只需要很简单的将这个模式扩展，就可以得到一个由很多节点构成的网络，但是当我们将这个模式扩展到比较大的规模，问题就接踵而来了，当我们有4个节点的时候，每个节点需要和除自己以外的节点都建立连接，如果A->B和B->A使用同一条连接的情况下，网络总共需要建立6条连接，当5个节点的时候就需要10条连接，节点间的连接数并不随节点数量线性增长。

四个节点如图所示：

<img src="https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_2/2_1.png?raw=true" width = "40%" height = "40%" alt="四个节点" align=center />

五个节点如图所示：

<img src="https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_2/2_2.png?raw=true" width = "50%" height = "50%" alt="四个节点" align=center />

在以太坊网络中，目前大概有8000多个全节点，如何我们按照这样的组织形式，显然是不能支撑如此大规模的节点组网。

最容易想到的方法是节点间不需要全量的连接，每个节点只要随机的保持和几个节点连接即可，而每个节点都这样，只要运气不是太差，整个网络也不会产生分区。

<img src="https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_2/1_3.jpg?raw=true" width = "50%" height = "50%" alt="四个节点" align=center />

在连接12，15，16三个节点的时候，都只有一条连接，当2号节点到12号节点的网络连接故障之后，及时15和16号节点的网络是正常的也无法连接到网络，针对这种这种情况只需要规定一个节点至少连接几个节点即可保证网络的健壮。

当我们想把消息从1号节点传播到16号节点的时候，可以看到通过1->2->15->16这个路径就可以把消息传递过去，每个节点只需要把自己接收到的消息进行告诉和自己建立连接的节点即可。

在Hyperledger Fabric中，节点间同步数据采用的是`Gossip`协议，Gossip协议的过程就是这样，当节点因为异常缺少账本数据时，可以通过`Gossip`协议从邻近的节点获得账本数据，保证集群中节点账本的一致性。

### Gossip协议
Gossip是流言的意思，很好的诠释了协议的过程，协议传输数据也是采用了类似流言传播的方式在集群中扩散。

Gossip 是一种去中心化思路的分布式协议，解决集群中的数据传播和状态一致性的问题。

#### 协议流程

- 节点A周期性的选择相邻的k个节点，并且向这K个节点发送自身存储的数据；
- K个节点接收到A发送过来的数据后，发现自身没有则存储下来，如果有则丢掉，并且重复节点A的过程。

![gossip](https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/gossip/1.gif?raw=true)


在节点A向节点K发送数据的时候有三种方式；
- `push`模式，节点A将数据（key，version，value）推送给K，K更新version比自己新的数据。
- `pull`模式，节点A将数据（key，version）推送给K，K将本地version比A新的数据推送给A。
- `push/pull`模式，先采用push模式更新K，然后采用pull模式更新A。

push模式需要通信一次，pull模式需要两次，pull/push模式需要通信三次，而从最终一致性的收敛速度也与通信次数成正比。将消息传播到所有节点的时间复杂度为log(n)。  

#### Gossip缺陷
- 消息的延迟，由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景。

- 消息冗余，Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送，因此，即使收到了消息的节点还会反复收到重复消息，加重了消息的冗余。

采用Gossip协议以后，我们想要确定性的想把一个消息传输给一个节点就变的不可能了，比如想把消息从1号节点确定的传输到16号节点，如果16号节点不在网络中了也可以明确的给我一个传输失败的反馈。

1号节点能做的只能是把想传播的消息告诉相邻的节点，然后期望是能被16号节点接收，如果失败了，也需要等待一会期待别的节点把消息广播给1号节。

导致这个问题最根本的原因就是Gossip协议中，无法计算节点间的距离，每个节点都不知道离目标节点到底还有多远，只能通过这样随机性的方法期待结果最终收敛。



