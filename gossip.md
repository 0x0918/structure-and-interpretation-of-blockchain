当我们通过一个密码体系可以构建两个节点的安全通信后，只需要很简单的将这个模式扩展，就可以得到一个由很多节点构成的网络，但是当我们将这个模式扩展到比较大的规模，问题就接踵而来了，当我们有4个节点的时候，每个节点需要和除自己以外的节点都建立连接，如果A->B和B->A使用同一条连接的情况下，网络总共需要建立6条连接，当5个节点的时候就需要10条连接，节点间的连接数并不随节点数量线性增长。

在以太坊网络中，目前大概有8000多个全节点，如何我们按照这样的组织形式，显然是不能支撑如此大规模的节点组网。


在Hyperledger Fabric中，节点间同步数据采用的是`Gossip`协议，当节点因为异常缺少账本数据时，可以通过`Gossip`协议从邻近的节点获得账本数据，保证集群中节点账本的一致性。

### Gossip协议
Gossip是流言的意思，很好的诠释了协议的过程，协议传输数据也是采用了类似流言传播的方式在集群中扩散。

Gossip 是一种去中心化思路的分布式协议，解决集群中的数据传播和状态一致性的问题。

#### 协议流程

- 节点A周期性的选择相邻的k个节点，并且向这K个节点发送自身存储的数据；
- K个节点接收到A发送过来的数据后，发现自身没有则存储下来，如果有则丢掉，并且重复节点A的过程。

![gossip](https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/gossip/1.gif?raw=true)

在节点A向节点K发送数据的时候有三种方式；
- `push`模式，节点A将数据（key，version，value）推送给K，K更新version比自己新的数据。
- `pull`模式，节点A将数据（key，version）推送给K，K将本地version比A新的数据推送给A。
- `push/pull`模式，先采用push模式更新K，然后采用pull模式更新A。

push模式需要通信一次，pull模式需要两次，pull/push模式需要通信三次，而从最终一致性的收敛速度也与通信次数成正比。将消息传播到所有节点的时间复杂度为log(n)。  

#### Gossip缺陷
- 消息的延迟，由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景。

- 消息冗余，Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送，因此，即使收到了消息的节点还会反复收到重复消息，加重了消息的冗余。
