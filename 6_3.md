# 字典树
有了默克尔树和默克尔证明这两种工具以后，解决了计算能力弱的设备证明交易上链的需求，也解决了数据完整性的需要。但是并没有解决具体的数据存储需要采用什么样的存储结构，比如采取数组，链表，哈希表或者是树结构。

比较朴素的想法是采用哈希表来进行存储，在常量个时间就可以实现数据的查询，但是这种方式并不适合与区块链场景，在区块链场景中，每一笔交易影响状态变更的账户数都是非常少的，如果维护一个全局的哈希表，每一次状态的变更都需要生成全量的根哈希，大量的重复计算会导致性能急剧下降，数组，链表也都存在相同的问题。

可以看到重复计算是导致性能下降的罪魁祸首，那解决这个问题的方法就是减少重复计算。

为了解决数据变更需要计算全量哈希和乱序数据默克尔证明不一致的问题，引入了一种新的数据结构。
## 字典树（Trie）

Trie又称前缀树或字典树，是一种有序树，用于保存关联数据，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。

下图是一颗典型的前缀树；

![](https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_6/6_3.png?raw=true)

图中前缀树存储了一些字符串，蓝色的是关键字，存储的字符串由关键字组成。存储了"a", "to", "tea", "ted", "ten", "i", "in", "inn"。
前缀树有这些特点；
- 根节点不包含字符，其他节点各包含一个字符；
- 关键路径节点的字符连接起来为该节点所存储的数据；

> 关键路径就是每个节点有一个标志位，用来标记这个节点是否作为构成数据的一部分，上图中的，t, e 节点就不是关键路径。

Trie的核心思想就是用空间换时间，利用公共前缀缩小要比较的范围来达到快速查找的目的。

如果Trie树叶上的数据发生了变化，只需要计算树叶到根路径上的哈希即可，避免了全量的哈希计算，相较于哈希表的方式，牺牲了一定的查询速度，多浪费了一些空间，但是也避免了大量的计算。

虽然相较于哈希表，插入和查询速度有不足，但是trie的插入和查询的效率依然算是非常高效的，都是O(m)，m是插入或查询字符串的长度，同时trie也支持了对数据按照字典序排序，这也是哈希表所不具备的特点。

对数据支持字典排序是一个非常重要的特性，相同的数据不同的顺序可能生成不同的根哈希，会误认为数据发生了变化，实际上数据本身没有改变，只是顺序发生了改变而已。

除此之外trie还在这些场景有广泛的应用；
- 但词频次统计。
- 字符串匹配。
- 字符串字典序排序。
- 前缀匹配，比如一些搜索框的自动提示。

## 压缩字典树

压缩字典树在字典树的基础之上做了一些优化，具体可以看下图；

![](https://github.com/Ice-Storm/structure-and-interpretation-of-blockchain/blob/master/img/chapter_6/6_4.png?raw=true)

图中黑色的是关键路径，存储了字符串"abc"和"d"，但是明显可以看到压缩后的前缀树占用了更小的空间。